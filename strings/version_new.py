# 版本号比较与加密（规则替换）
# 用户输入两个版本号 v1 和 v2，请编写代码比较它们，找出较新的版本。
# 版本号是由一个或多个修订号组成，各个修订号之间由点号（.）连接，每个修订号由多位数字组成，例如 1.2.33 和 0.0.11 都是有效的版本号。
# 从左到右的顺序依次比较它们的修订号，点号（.）左侧的值要比右侧的权重大，即 0.1 要比 0.0.99 大。
v1 = input("请输入第一个版本号，v1 = ")
v2 = input("请输入第二个版本号，v2 = ")
m, n = len(v1), len(v2)
i, j = 0, 0
x, y = 0, 0
while i < m or j < n:
    x, y = 0, 0
    # 舍弃. 直接用数字进行比较
    while i < m and v1[i] != '.':
        x = x * 10 + int(v1[i])
        i += 1
    i += 1
    while j < n and v2[j] != '.':
        y = y * 10 + int(v2[j])
        j += 1
    j += 1
    if x > y:
        print("v1")
        break
    elif x < y:
        print("v2")
if x == y:
    print("v1 == v2")
# 请输入第一个版本号，v1 = 1.0.0
# 请输入第二个版本号，v2 = 1
# v1 == v2

# 加密
# 编写一个加密程序，其实现原理是通过替换指定的字符进行加密，附加要求是实现密文逆向检测。
s = input("请输入需要加密的明文：")
t1 = input("请输入需要替换的字符：")
t2 = input("请输入将1要替换的字符：")
i = 0
if len(t1) == len(t2):
    table = str.maketrans(t1, t2)
    print("加密后的密文是：", s.translate(table))
    while i < len(t1) - 1:
        if t1[i] == t1[i + 1] or t2[i] == t2[i + 1]:
            print("由于替换字符出现冲突，该密文无法解密！")
            break
        i += 1
else:
    print("需要替换的字符数量必须跟将要替换的字符数量一致！")
